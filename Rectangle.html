<!DOCTYPE html>
<html>

<head>
    <title>Draggable Rectangles</title>
    <style>
        body {
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            border: 1px solid black;
            display: block;
            margin-top: 20px;
            margin-left: 20px;
        }

        form {
            display: flex;
            flex-direction: column;
            width: 200px;
            margin-bottom: 20px;
        }

        .tab {
            display: flex;
            flex-wrap: wrap;
        }

        .tab>input[type="radio"] {
            display: none;
        }

        .tab-content {
            display: none;
            width: 100%;
            margin-top: 1rem;
        }

        .tab>label {
            display: block;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out;
            text-decoration: none;
            color: #0d6efd;
            border: 0;
            border-radius: 0.375rem;
            background: 0 0;
        }

        .tab>input[type="radio"]:checked+label {
            cursor: default;
            color: #fff;
            background-color: #0d6efd;
        }



        /* Modal styles */
        .modal {
            display: none;
            /* Скрыть модальное окно по умолчанию */
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            /* Полупрозрачный фон */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #fff;
            padding: 20px;
            border-radius: 5px;
            text-align: center;
        }

        button {
            margin: 5px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #a4b4a8;
        }

        button:active {
            background-color: #86978a;
        }

        button#saveConfirm,
        button#deleteConfirm {
            background-color: #4CAF50;
            color: white;
        }

        button#saveCancel,
        button#deleteCancel {
            background-color: #f44336;
            color: white;
        }
    </style>
</head>

<body>
    <!-- Необычные случаи 700 700 450 200; 400 400 140 120 -->
    <form id="canvasForm">
        <label for="palletWidth">Ширина:</label>
        <input type="number" id="palletWidth" value="600" required>
        <label for="palletHeight">Высота:</label>
        <input type="number" id="palletHeight" value="600" required>
        <label for="rectWidth">Ширина прямоугольника:</label>
        <input type="number" id="rectWidth" value="310" required>
        <label for="rectHeight">Высота прямоугольника:</label>
        <input type="number" id="rectHeight" value="30" required>
        <label for="inentM">Минимальный отступ:</label>
        <input type="number" id="inentM" value="10" required>
        <label for="minLayer">Количество слоев</label>
        <input type="number" id="minLayer" value="2" required>
        <button type="button" id='plus'>+</button>
        <button type="button" id='rotate'>↻</button>
        <!-- <button type="button" id='dob'>Добавить прямоугольник</button> -->
        <button type="submit">Apply</button>
    </form>

    <div class="tab">
    </div>

    <canvas id="myCanvas" width="800" height="800"></canvas>
    <ul>


        <li><strike>Проверка на кладку диагональную (высота среди широты) (440 420 140 120 6)</strike></li>
        <li><strike>Менять местами при кладке при доп горизонт, допВерт</strike></li>
        <li><strike>Поворот окна</strike></li>
        <li><strike>Сохранять измененный слой руками и спрашивать при нажатии на дополнительный слой (либо на переход в
                другой
                слой без кнокпи сохранения) сделать ли все последующие такие (через 1) или нет</strike></li> +-
        <li>Изменение масштаба либо окна (canvas) при изменении паллета</li>
        <li>Добавить в форму вопрос про кол-во мешков (Если нет параметра вычислять самостоятельно от массы + добавить в
            форму массу)</li>
        <li>Добавить возможность перемещения нескольких объектов (выделять их, разобрать код из test.html) (?)</li>
        <li>Приятный интерфейс</li>
        <li>700 700 450 200 10</li>
        <li>600 600 140 120 10 ---</li>
        <li>600 600 145 20 10 Кладка рядами столбцами</li>
        <li>600 600 310 30 10 Кладка квадратом</li>
        <li>600 600 450 30 10 спрашивать вопрос про укладку по устойчивости или по максимальной вместимости</li>
        <li>600 600 286 120 10 Кладка квадратом</li>
    </ul>

    <div id="saveQuestion" class="modal">
        <div class="modal-content">
            <p>Вы уверены, что хотите переключить слой? Изменения будут потеряны.</p>
            <button id="saveConfirm">Сохранить</button>
            <button id="saveCancel">Отмена</button>
        </div>
    </div>

    <div id="deleteQuestion" class="modal">
        <div class="modal-content">
            <p>Вы уверены, что хотите безвозвратно удалить объект?</p>
            <button id="deleteConfirm">Удалить</button>
            <button id="deleteCancel">Отмена</button>
        </div>
    </div>

    <script>
        "use strict";


        const form = document.getElementById('canvasForm');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let selectedRectangle;

        let centerX, centerY, predelX, predelY;
        let rectWidth, rectHeight, rectCount;
        let rectangles = [];
        let inent;
        let level = 1;
        let layerNum = 0;
        let arrText = ['↑', '→', '↓', '←'];
        let dragOffsetY, dragOffsetX;
        let rgbColor = ``;
        let flagAddVert = false;
        let flagAddHoriz = false;
        let spacingCenterX = 0;
        let spacingCenterY = 0;

        function float2int(value) {
            return value | 0; // Побитывая операция
        }
        function filterAndSortElements(arr, widthProp, sortProp) {
            return arr
                .filter(item => item.width !== widthProp)
                .sort((a, b) => a[sortProp] - b[sortProp]);
        }

        function calculateSpacing(lastElement, element, widthOrHeightProp, positionProp, startIndex, endIndex) {
            const totalGap = lastElement[positionProp] + float2int(lastElement[widthOrHeightProp] / 2)
                - (element[positionProp] + float2int(element[widthOrHeightProp] / 2));
            return float2int(totalGap / (endIndex - startIndex));
        }

        function updateElementPositions(arr1Layer, widthOrHeightProp, rowOrColumnProp, positionProp) {
            // Найдите последний элемент с нужной шириной
            const normalLastRec = arr1Layer.findLast(item => item.width === rectWidth);

            // Отфильтруйте и отсортируйте элементы
            const filteredAndSortedElements = filterAndSortElements(arr1Layer, rectWidth, rowOrColumnProp);

            if (filteredAndSortedElements.length === 0) return; // Если нет элементов для обработки

            let currentRowOrColumnValue = filteredAndSortedElements[0][rowOrColumnProp];
            let startIndexOfCurrentGroup = 0;

            // Обработайте элементы по группам
            for (let i = 0; i < filteredAndSortedElements.length; i++) {
                if (filteredAndSortedElements[i + 1]?.[rowOrColumnProp] !== currentRowOrColumnValue) {

                    const currentGroup = filteredAndSortedElements.slice(startIndexOfCurrentGroup + 1, i + 1);
                    const spacing = calculateSpacing(normalLastRec, filteredAndSortedElements[i], widthOrHeightProp, positionProp, startIndexOfCurrentGroup, i);

                    currentGroup.forEach((item, index) => {
                        const arrIndex = arr1Layer.indexOf(item);
                        arr1Layer[arrIndex][positionProp] += spacing * (index + 1);
                        arr1Layer[arrIndex][positionProp + 'Auto'] = arr1Layer[arrIndex][positionProp];
                    });

                    startIndexOfCurrentGroup = i + 1;
                    currentRowOrColumnValue = filteredAndSortedElements[i + 1]?.[rowOrColumnProp];
                }
            }
        }

        // Универсальная функция для вычисления координат
        function calculateCoordinate(arr1Layer, i, j, rectSize, isVertical, flagAdd) {
            const center = isVertical ? centerX : centerY;
            const rectProp = isVertical ? 'width' : 'height';
            const coordProp = isVertical ? 'x' : 'y';

            if ((isVertical && i === 0) || (!isVertical && j === 0)) {
                return float2int(-(center - rectSize / 2));
            }

            let rightIndex = arr1Layer.findIndex(item =>
                (flagAdd ? item[isVertical ? 'column' : 'row'] === (isVertical ? i - 1 : j - 1) && item[rectProp] === rectSize : item[isVertical ? 'column' : 'row'] === (isVertical ? i - 1 : j - 1))
            );

            if ((layingSquareVert || layingSquareHoriz) && j != 0) {
                rightIndex = arr1Layer.findLastIndex(item => item[isVertical ? 'column' : 'row'] === (isVertical ? i - 1 : j - 1));
            }


            if (layingSquareHoriz && i == countDopHorizHoriz + 1) {
                let rightIndexX = 1;
                if (isVertical) {
                    let rightItemX = arr1Layer[rightIndexX];
                    if (!rightItemX) return 0;

                    if (rightItemX[rectProp] > rectSize) {
                        return rightItemX[coordProp] + rightItemX[rectProp] - Math.floor((rightItemX[rectProp] - rectSize) / 2);
                    } else if (rightItemX[rectProp] < rectSize) {
                        return rightItemX[coordProp] + rightItemX[rectProp] + Math.floor((rectSize - rightItemX[rectProp]) / 2);
                    } else {
                        return rightItemX[coordProp] + rightItemX[rectProp];
                    }
                }

            }


            const rightItem = arr1Layer[rightIndex];
            if (!rightItem) return 0;

            if (rightItem[rectProp] > rectSize) {
                return rightItem[coordProp] + rightItem[rectProp] - Math.floor((rightItem[rectProp] - rectSize) / 2);
            } else if (rightItem[rectProp] < rectSize) {
                return rightItem[coordProp] + rightItem[rectProp] + Math.floor((rectSize - rightItem[rectProp]) / 2);
            } else {
                return rightItem[coordProp] + rightItem[rectProp];
            }
        }

        // Функция для обновления текста на основе условий
        function determineText(arr, i, j, arrText) {
            if (arr[i][j] === 2) {
                changeWidthHeight();

            }
            return (parseInt(document.getElementById('rectWidth').value) != rectWidth) ?
                (i === 0) ? arrText[1] : arrText[3] :
                (j === 0) ? arrText[2] : arrText[0];
        }

        function centering(arr) {
            let maxX = -Infinity;
            let maxY = -Infinity;

            arr.forEach(item => {
                let itemX = item.x + float2int(item.width / 2) + inent
                let itemY = item.y + float2int(item.height / 2) + inent
                if (itemY > maxY) {
                    maxY = itemY;
                }
                if (itemX > maxX) {
                    maxX = itemX;
                }
            });

            const gapXAxis = float2int((float2int(palletWidth.value / 2) - maxX) / 2);
            const gapYAxis = float2int((float2int(palletHeight.value / 2) - maxY) / 2);

            arr.forEach(rect => {
                rect.x += gapXAxis;
                rect.y += gapYAxis;
                rect.xAuto += gapXAxis;
                rect.yAuto += gapYAxis;
            });
        }

        // Основная функция
        function getCoord(arr) {
            let coordinateX = 0;
            let coordinateY = 0;
            let arr1Layer = [];
            let text = arrText[2];

            for (let i = 0; i < arr.length; i++) {
                if (!arr1Layer?.at(-1)?.isLastlayer) {
                    rgbColor = `rgb(${getRandomInt(255)} ${getRandomInt(255)} ${getRandomInt(255)} / 50%)`;
                }

                for (let j = 0; j < arr[i].length; j++) {
                    if (arr[i][j] === 0) continue;

                    text = determineText(arr, i, j, arrText);
                    coordinateX = calculateCoordinate(arr1Layer, i, j, rectWidth, true, flagAddVert);
                    coordinateY = calculateCoordinate(arr1Layer, i, j, rectHeight, false, flagAddHoriz);

                    const item = {
                        x: coordinateX + inent,
                        y: coordinateY + inent,
                        width: rectWidth,
                        height: rectHeight,
                        isDragging: false,
                        isLastlayer: true,
                        color: rgbColor,
                        text: text,
                        column: i,
                        row: j,
                        layer: level,
                        xAuto: coordinateX + inent,
                        yAuto: coordinateY + inent,
                        widthAuto: rectWidth,
                        heightAuto: rectHeight,
                        textAuto: text,
                        colorAuto: rgbColor
                    };

                    arr1Layer.push(item);

                    if (arr[i][j] === 2) {
                        changeWidthHeight();
                    }
                }
            }

            if (flagAddVert) {
                updateElementPositions(arr1Layer, 'width', 'row', 'x');
            }
            if (flagAddHoriz) {
                updateElementPositions(arr1Layer, 'height', 'column', 'y');
            }

            centering(arr1Layer);

            rectangles.push(...arr1Layer);

            flagAddHoriz = false;
            flagAddVert = false;
            layingSquareVert = false;
            layingSquareHoriz = false;
        }



        function changeWidthHeight() {
            [rectWidth, rectHeight] = [rectHeight, rectWidth];
        }

        function findDopRectangles(palletWidth, palletHeight, lengthRect, widthRect) {
            let dopHoriz = { horizontal: 0, vertical: 0 };
            let dopVert = { horizontal: 0, vertical: 0 };
            if (lengthRect + rectHeight + inent <= palletWidth) {
                dopHoriz.horizontal++;
                while (lengthRect + (rectHeight + inent) * (dopHoriz.horizontal + 1) <= palletWidth) {
                    dopHoriz.horizontal++;
                }
                if (rectWidth + inent + inent <= palletHeight) {
                    dopHoriz.vertical++;

                    while ((rectWidth + inent) * (dopHoriz.vertical + 1) + inent <= palletHeight) {
                        dopHoriz.vertical++;
                    }
                } else {
                    dopHoriz.horizontal = 0;
                }
            } else if (widthRect + rectWidth + inent <= palletHeight) {
                dopVert.vertical++;
                while (widthRect + (rectWidth + inent) * (dopVert.vertical + 1) <= palletHeight) {
                    dopVert.vertical++;
                }
                if (rectHeight + inent + inent <= palletWidth) {
                    dopVert.horizontal++;
                    while ((rectHeight + inent) * (dopVert.horizontal + 1) + inent <= palletWidth) {
                        dopVert.horizontal++;
                    }
                } else {
                    dopVert.vertical = 0;
                }
            }

            return [dopHoriz, dopVert];
        }

        function findNumberOfRectangles(palletWidth, palletHeight) {
            // let dopRectangles = {};
            let numRectangles = {};

            let numHorizontal = Math.floor((palletWidth - inent) / (rectWidth + inent));
            let lengthRect = numHorizontal * (rectWidth + inent) + inent;
            let numVertical = Math.floor((palletHeight - inent) / (rectHeight + inent));
            let widthRect = numVertical * (rectHeight + inent) + inent;

            let [dopHoriz, dopVert] = findDopRectangles(palletWidth, palletHeight, lengthRect, widthRect)

            if (numHorizontal != 0 && numVertical != 0) {
                numRectangles = { horizontal: numHorizontal, vertical: numVertical, dopHoriz: dopHoriz, dopVert: dopVert };
            } else {
                alert('Не подходящие параметры')
            }

            return numRectangles;

        }
        function createBaseMatrix(numRows, numCols, number) {
            return Array(numRows).fill().map(() => Array(numCols).fill(number));
        }

        let layingSquareHoriz = false;
        let layingSquareVert = false;
        let countDopHorizHoriz = 0;

        function oddLayer(palletWidth, palletHeight) {
            // let matrixRectangles = [];
            centerX = Math.floor(palletWidth / 2) ;
            centerY = Math.floor(palletHeight / 2) ;
            let numRectangles = findNumberOfRectangles(palletWidth, palletHeight);



            let matrixRectangles = createBaseMatrix(numRectangles.horizontal, numRectangles.vertical, 1);

            let matrixLenght = matrixRectangles.length;
            // Для дополнительных горизонтальных (если одинаковое кол-во столбцов обычных и дополнительных (+1)) распределение по столбцам
            if (numRectangles.dopHoriz.horizontal) {
                //Кладка квадратом
                if (numRectangles.dopHoriz.vertical == 1 && numRectangles.horizontal == 1 && (numRectangles.dopHoriz.horizontal > 2 || numRectangles.vertical > 2)) {
                    layingSquareHoriz = true;
                    countDopHorizHoriz = numRectangles.dopHoriz.horizontal; // поменять название
                    // console.log(countDopHorizHoriz)
                    const rowsToRemove = numRectangles.vertical - countDopHorizHoriz;
                    for (let k = 0; k < rowsToRemove; k++) {
                        matrixRectangles.forEach(row => row.pop());
                    }
                    matrixRectangles[0].unshift(2);

                    const additionalRows = createBaseMatrix(countDopHorizHoriz - 1, 1, 2).map(row => {
                        // Добавляем нули в каждую строку
                        row.push(...Array(countDopHorizHoriz).fill(0));
                        return row;
                    });

                    matrixRectangles.push(...additionalRows);

                    matrixRectangles.push(Array(countDopHorizHoriz).fill(1));
                    matrixRectangles[matrixRectangles.length - 1].push(0);

                    // Создайте копию массива, чтобы не изменять оригинал
                    const reversedDopArr = additionalRows.map(arr => [...arr].reverse());
                    if (reversedDopArr.length !== 0) {
                        matrixRectangles.push(...reversedDopArr);
                        matrixRectangles.push(reversedDopArr[0]);
                    } else {
                        matrixRectangles.push(Array(countDopHorizHoriz).fill(0));
                        matrixRectangles.at(-1).push(2);
                    }




                    //     matrixRectangles.splice(matrixRectangles.length, 0, dopArr);
                    // matrixRectangles = [
                    //     [2, 1, 1, 1, 1, 1, 1],
                    //     [2, 0, 0, 0, 0, 0, 0],
                    //     [2, 0, 0, 0, 0, 0, 0],
                    //     [2, 0, 0, 0, 0, 0, 0],
                    //     [2, 0, 0, 0, 0, 0, 0],
                    //     [2, 0, 0, 0, 0, 0, 0],
                    //     [1, 1, 1, 1, 1, 1, 0],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    //     [0, 0, 0, 0, 0, 0, 2],
                    // ]

                }
                else {
                    flagAddHoriz = true;
                    for (let i = 0; i < numRectangles.dopHoriz.horizontal; i++) {

                        let dopArr = Array(numRectangles.dopHoriz.vertical).fill(2);

                        if (numRectangles.horizontal > numRectangles.dopHoriz.horizontal) {
                            matrixRectangles.splice((i + 1) + matrixRectangles.length - matrixLenght, 0, dopArr);
                        }
                        else {
                            matrixRectangles.splice(i + matrixRectangles.length - matrixLenght, 0, dopArr); // numRectangles.dopHoriz.horizontal
                        }

                    }
                }
            }
            // Для дополнительных вертикальных (если одинаковое кол-во столбцов обычных и дополнительных (+1)) распределение по рядам
            if (numRectangles.dopVert.vertical) {
                //Кладка квадратом
                if (numRectangles.dopVert.horizontal == 1 && numRectangles.vertical == 1 && (numRectangles.dopVert.vertical > 2 || numRectangles.horizontal > 2)) {
                    layingSquareVert = true;
                    let differenceValues = numRectangles.dopVert.vertical; // поменять название
                    let dopArr = Array(differenceValues).fill(2);

                    for (let k = 0; k < numRectangles.horizontal - differenceValues; k++) {
                        matrixRectangles.pop();
                    }

                    for (let k = 0; k < matrixRectangles.length; k++) {
                        matrixRectangles[k].push(...Array(differenceValues - 1).fill(0));
                    }

                    matrixRectangles.splice(0, 0, dopArr);

                    matrixRectangles = matrixRectangles[0].map((_, colIndex) => matrixRectangles.map(row => row[colIndex]));
                    for (let k = 1; k < matrixRectangles.length; k++) {
                        matrixRectangles[k].splice(matrixRectangles[k].length - numRectangles.dopVert.horizontal, numRectangles.dopVert.horizontal, ...Array(numRectangles.dopVert.horizontal).fill(2));
                    }
                    dopArr = matrixRectangles[0].slice().reverse()
                    // console.log(matrixRectangles[0].slice().reverse())
                    matrixRectangles.splice(matrixRectangles.length, 0, dopArr);

                    matrixRectangles = matrixRectangles[0].map((_, colIndex) => matrixRectangles.map(row => row[colIndex]));




                }
                //Кладка по столбцам, рядам
                else {


                    flagAddVert = true;
                    matrixRectangles = matrixRectangles[0].map((_, colIndex) => matrixRectangles.map(row => row[colIndex]));
                    matrixLenght = matrixRectangles.length;
                    for (let i = 0; i < numRectangles.dopVert.vertical; i++) {

                        let dopArr = Array(numRectangles.dopVert.horizontal).fill(2);
                        let dopArr1 = Array(numRectangles.horizontal - numRectangles.dopVert.horizontal).fill(0);

                        if (numRectangles.vertical > numRectangles.dopVert.vertical) {
                            matrixRectangles.splice((i + 1) + matrixRectangles.length - matrixLenght, 0, dopArr.concat(dopArr1));
                        }
                        else {
                            matrixRectangles.splice((i) + matrixRectangles.length - matrixLenght, 0, dopArr.concat(dopArr1));
                        }

                    }
                    // matrixRectangles = [[1, 1, 1, 1, 1, 1, 2]];
                    matrixRectangles = matrixRectangles[0].map((_, colIndex) => matrixRectangles.map(row => row[colIndex]));

                }

                // newArr = newArr[0].map((_, colIndex) => newArr.map(row => row[colIndex]));
                // console.log(newArr)
            }
            // console.log(matrixRectangles);
            getCoord(matrixRectangles);

        }

        function rotateRectangles(rectangles, centerX, centerY) {
            // Создаём новый массив для хранения повернутых прямоугольников
            let rotatedRectangles = rectangles.filter(item => item.layer == layerNum).map(rect => {
                // Вычисляем новые координаты
                let newX = -rect.y;
                let newY = rect.x;

                // Обновляем размеры
                let newWidth = rect.height;
                let newHeight = rect.width;

                // Присваиваем новые значения прямоугольника
                rect.x = newX;
                rect.y = newY;
                rect.height = newHeight;
                rect.width = newWidth;
                rect.text = (arrText.indexOf(rect.text) == arrText.length - 1) ? arrText[0] : arrText[arrText.indexOf(rect.text) + 1];
            });

            drawLayer();
        }
        function invertColor(rgbColor) {
            // Извлечение R, G, B из строки
            let [r, g, b] = rgbColor.match(/\d+/g).map(Number);

            // Инвертирование цвета
            let invertedR = 255 - r;
            let invertedG = 255 - g;
            let invertedB = 255 - b;

            // Возвращаем инвертированный цвет
            return `rgb(${invertedR} ${invertedG} ${invertedB} / 50%)`;
        }

        plus.addEventListener('click', evt => {
            let lastRectangleLayerIndex = rectangles.findLastIndex(rect => rect.layer == layerNum);
            let lastRectangleLayer = rectangles[lastRectangleLayerIndex];

            // При добавлении нового прямоугольника возвращать цвет прошлого.
            lastRectangleLayer.color = rectangles[lastRectangleLayerIndex - 1].color;


            const item = {
                x: 0,
                y: 0,
                width: lastRectangleLayer.width,
                height: lastRectangleLayer.height,
                isDragging: false,
                isLastlayer: true,
                color: invertColor(lastRectangleLayer.color),
                text: lastRectangleLayer.text,
                column: lastRectangleLayer.column,
                row: lastRectangleLayer.row,
                layer: lastRectangleLayer.layer,
                xAuto: 0,
                yAuto: 0,
                widthAuto: lastRectangleLayer.widthAuto,
                heightAuto: lastRectangleLayer.heightAuto,
                textAuto: lastRectangleLayer.textAuto,
                colorAuto: lastRectangleLayer.colorAuto
            };

            rectangles.splice(lastRectangleLayerIndex + 1, 0, item);

            drawLayer();
        });

        rotate.addEventListener('click', evt => {
            rotateRectangles(rectangles, centerX, centerY);
        });




        form.addEventListener('submit', function (event) {
            event.preventDefault();
            rectangles = [];
            spacingCenterX = float2int((parseInt(document.getElementById('myCanvas').width) - parseInt(document.getElementById('palletWidth').value) * scale) / 2);
            spacingCenterY = float2int((parseInt(document.getElementById('myCanvas').height) - parseInt(document.getElementById('palletHeight').value) * scale) / 2);
            ctx.setTransform(scale, 0, 0, scale, spacingCenterX, spacingCenterY);
            level = 1;
            let child = tab.lastElementChild;
            while (child) {
                tab.removeChild(child);
                child = tab.lastElementChild;
            }

            const palletWidth = parseInt(document.getElementById('palletWidth').value);
            const palletHeight = parseInt(document.getElementById('palletHeight').value);
            inent = Number(document.getElementById('inentM').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            rectHeight = parseInt(document.getElementById('rectHeight').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            let layer = parseInt(document.getElementById('minLayer').value);

            // Показ всех слоев одновременно
            for (let i = 0; i < layer; i++) {
                for (let i = 0; i < rectangles.length; i++) {
                    rectangles[i].isLastlayer = false;
                }

                // getRectangles(palletWidth, palletHeight);
                if (level % 2 != 0) {
                    changeWidthHeight();
                    oddLayer(palletWidth, palletHeight)
                    changeWidthHeight();

                    level += 1;
                } else {
                    oddLayer(palletWidth, palletHeight);
                    level += 1;
                }

            }

            createButton(layer);
            // console.log(rectangles)
            // oddLayer(palletWidth, palletHeight);
            layerNum = layer;
            drawLayer();
        });


        const tab = document.querySelector('.tab');
        const saveQuestion = document.getElementById('saveQuestion');
        const saveConfirm = document.getElementById('saveConfirm');
        const saveCancel = document.getElementById('saveCancel');

        let pendingSwitch = null;

        function createButton(quantity) {

            for (let i = 1; i <= quantity; i++) {
                // <input checked id="tab-btn-1" name="tab-btn" type="radio" value="">
                // <label for="tab-btn-1">Вкладка 1</label>
                const button = document.createElement('input');
                button.setAttribute('type', 'radio');
                button.setAttribute("checked", "");
                button.name = "tab-bth";
                button.id = `tab-bth-${i}`;
                button.classList.add('btn');
                button.addEventListener('click', () => {

                    if (hasUnsavedChanges()) {
                        pendingSwitch = i; // Запоминаем слой, на который нужно переключиться
                        saveQuestion.style.display = 'flex';

                    } else {
                        layerNum = i;
                        drawLayer();
                    }


                })
                tab.appendChild(button);
                const label = document.createElement('label');
                label.setAttribute("for", `tab-bth-${i}`);
                label.innerHTML = `Слой ${i}`
                tab.appendChild(label);
            }

        }
        function switchLayer() {
            if (pendingSwitch !== null) {
                layerNum = pendingSwitch; // Переключаемся на запомненный слой
                drawLayer();
                pendingSwitch = null; // Сбрасываем запомненный слой
            }
        }

        function hasUnsavedChanges() {
            return rectangles.some(rectangle =>
                rectangle.x !== rectangle.xAuto || rectangle.y !== rectangle.yAuto
            );
        }
        function updateDataRectangles() {
            const filteredRectangles = rectangles.filter(rectangle => rectangle.layer === layerNum);

            // Обновляем свойства для отфильтрованных элементов
            filteredRectangles.forEach(rectangle => {
                rectangle.xAuto = rectangle.x;
                rectangle.yAuto = rectangle.y;
                rectangle.widthAuto = rectangle.width;
                rectangle.heightAuto = rectangle.height;
                rectangle.textAuto = rectangle.text;
                rectangle.color = rectangle.colorAuto;
            });
        }

        function returnDataRectangles() {
            const filteredRectangles = rectangles.filter(rectangle => rectangle.layer === layerNum);

            filteredRectangles.forEach(rectangle => {
                rectangle.x = rectangle.xAuto;
                rectangle.y = rectangle.yAuto;
                rectangle.width = rectangle.widthAuto;
                rectangle.height = rectangle.heightAuto;
                rectangle.text = rectangle.textAuto;
                rectangle.color = rectangle.colorAuto;
            });
        }

        saveConfirm.addEventListener('click', () => {
            updateDataRectangles();
            saveQuestion.style.display = 'none'; // Закрываем модальное окно
            switchLayer()

        });

        saveCancel.addEventListener('click', () => {
            returnDataRectangles();
            saveQuestion.style.display = 'none'; // Закрываем модальное окно
            switchLayer()
        });

        function drawLayer() {
            let startLayer = -1;
            let endLayer = -1;
            ctx.clearRect(-spacingCenterX, -spacingCenterY, canvas.width + spacingCenterX, canvas.height +spacingCenterY);
            for (var i = 0; i < rectangles.length; i++) {
                rectangles[i].isLastlayer = false;

                if (rectangles[i].layer == layerNum && startLayer == -1) {
                    startLayer = i;
                }
                if (rectangles[i].layer == layerNum + 1 && endLayer == -1) {
                    endLayer = i;
                }
            }

            for (let i = startLayer; i < ((endLayer == -1) ? rectangles.length : endLayer); i++) {
                rectangles[i].isLastlayer = true;
            }
            
            rectangles.slice(0, ((endLayer == -1) ? rectangles.length : endLayer)).forEach(drawRectangle);
            drawPallet();

        }


        function drawPallet() {
            const palletWidth = parseInt(document.getElementById('palletWidth').value);
            const palletHeight = parseInt(document.getElementById('palletHeight').value);
            ctx.strokeRect(0, 0, palletWidth, palletHeight);
        }


        function drawRectangle(rect) {
            ctx.beginPath();
            drawNumbers(rect);
            drawArrow(rect);

            ctx.rect(centerX + rect.x - float2int(rect.width / 2), centerY + rect.y - float2int(rect.height / 2), rect.width, rect.height);

            ctx.fillStyle = rect.color;
            ctx.fill();
            if (!rect.isLastlayer) {
                ctx.strokeStyle = rect.color;
            } else {
                ctx.strokeStyle = 'black'
            }

            ctx.stroke();
        }

        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }


        function drawNumbers(rect) {
            ctx.font = "15px arial";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }

            let text = (rect.x).toString() + ', ' + (-rect.y).toString();
            ctx.fillText(text, centerX + rect.x, centerY + rect.y);
        }

        function drawArrow(rect) {
            ctx.font = "24px arial";
            ctx.textBaseline = "middle";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }
            if (rect.text == '↑') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
            } else if (rect.text == '→') {
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else if (rect.text == '←') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            }

        }


        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / scale - spacingCenterX / scale,
                y: (evt.clientY - rect.top) / scale - spacingCenterY / scale
            };
        }

        function isInsideRect(mousePos, rect) {
            return mousePos.x > centerX + rect.x - float2int(rect.width / 2) &&
                mousePos.x < centerX + rect.x + float2int(rect.width / 2) &&
                mousePos.y > centerY + rect.y - float2int(rect.height / 2) &&
                mousePos.y < centerY + rect.y + float2int(rect.height / 2);
        }

        //Отключение контекстного меню
        document.addEventListener('contextmenu', function (event) {
            event.preventDefault();
        });

        const deleteQuestion = document.getElementById('deleteQuestion');
        const deleteConfirm = document.getElementById('deleteConfirm');
        const deleteCancel = document.getElementById('deleteCancel');

        deleteConfirm.addEventListener('click', () => {
            let indexDeleted = rectangles.indexOf(selectedRectangle);
            deleteQuestion.style.display = 'none'; // Закрываем модальное окно
            rectangles.splice(indexDeleted, 1);
            selectedRectangle = null;
            drawLayer();

        });

        deleteCancel.addEventListener('click', () => {
            deleteQuestion.style.display = 'none'; // Закрываем модальное окно

            selectedRectangle = null;

        });

        canvas.addEventListener('mousedown', function (evt) {

            const mousePos = getMousePos(canvas, evt);
            rectangles.forEach(rect => {
                if (isInsideRect(mousePos, rect) && rect.isLastlayer) {
                    selectedRectangle = rect;
                    if (evt.button === 0) {
                        dragOffsetX = mousePos.x - (centerX + rect.x);
                        dragOffsetY = mousePos.y - (centerY + rect.y);
                        rect.isDragging = true;
                    }
                }
            });
            if (evt.button === 1 && selectedRectangle) {
                evt.preventDefault();
                let dop = selectedRectangle.height;
                selectedRectangle.height = selectedRectangle?.width;
                selectedRectangle.width = dop;
                selectedRectangle.isDragging = false;
                if (arrText.indexOf(selectedRectangle.text) + 1 < arrText.length) {
                    selectedRectangle.text = arrText[arrText.indexOf(selectedRectangle.text) + 1];
                } else {
                    selectedRectangle.text = arrText[0];
                }

                drawLayer();

            }
            if (evt.button === 2 && selectedRectangle) {

                deleteQuestion.style.display = 'flex';


            }
        });

        canvas.addEventListener('mousemove', function (evt) {
            if (selectedRectangle && selectedRectangle.isDragging) {
                const mousePos = getMousePos(canvas, evt);
                if ((mousePos.x - centerX - dragOffsetX) > 0) {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) > (centerX - float2int(selectedRectangle.width / 2) )) ? (centerX - float2int(selectedRectangle.width / 2)) : float2int(mousePos.x - centerX - dragOffsetX);
                } else {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) < -(centerX - float2int(selectedRectangle.width / 2) )) ? -(centerX - float2int(selectedRectangle.width / 2)) : float2int(mousePos.x - centerX - dragOffsetX);
                }

                if ((mousePos.y - centerY - dragOffsetY) > 0) {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) > (centerY - float2int(selectedRectangle.height / 2))) ? (centerY - float2int(selectedRectangle.height / 2)) : float2int(mousePos.y - centerY - dragOffsetY);
                } else {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) < -(centerY - float2int(selectedRectangle.height / 2))) ? -(centerY - float2int(selectedRectangle.height / 2)) : float2int(mousePos.y - centerY - dragOffsetY);
                }

                // selectedRectangle.y = mousePos.y - centerY - dragOffsetY;
                drawLayer();
            }
        });

        canvas.addEventListener('mouseup', function () {
            if (selectedRectangle) {
                selectedRectangle.isDragging = false;
                selectedRectangle = null;
            }
        });

        function setCanvasScale(scale) {
            ctx.clearRect(-spacingCenterX, -spacingCenterY, canvas.width + spacingCenterX, canvas.height +spacingCenterY);
            spacingCenterX = float2int((parseInt(document.getElementById('myCanvas').width) - parseInt(document.getElementById('palletWidth').value) * scale) / 2);
            spacingCenterY = float2int((parseInt(document.getElementById('myCanvas').height) - parseInt(document.getElementById('palletHeight').value) * scale) / 2);
            // Сбрасываем трансформацию и устанавливаем новый масштаб
            ctx.setTransform(scale, 0, 0, scale, spacingCenterX, spacingCenterY);
            drawLayer(); // Перерисовываем слой после изменения масштаба

        }

        let scale = 1;
        document.addEventListener('keydown', evt => {
            
            if (evt.code === 'Minus') {
                scale = Math.max(0.1, scale - 0.1); // Ограничиваем масштаб, чтобы не стало меньше 0.1
                setCanvasScale(scale);
            } else if (evt.code === 'Equal') {
                scale += 0.1;
                setCanvasScale(scale);
            }
        });


        // Инициализация при загрузке
        form.dispatchEvent(new Event('submit'));
    </script>
</body>

</html>