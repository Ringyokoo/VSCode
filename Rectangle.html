<!DOCTYPE html>
<html>

<head>
    <title>Draggable Rectangles</title>
    <style>
        body {
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            border: 1px solid black;
            display: block;
            margin-top: 20px;
            margin-left: 20px;
        }

        form {
            display: flex;
            flex-direction: column;
            width: 200px;
            margin-bottom: 20px;
        }

        .tab {
            display: flex;
            flex-wrap: wrap;
        }

        .tab>input[type="radio"] {
            display: none;
        }

        .tab-content {
            display: none;
            width: 100%;
            margin-top: 1rem;
        }

        /* #tab-btn-1:checked~#content-1,
        #tab-btn-2:checked~#content-2,
        #tab-btn-3:checked~#content-3 {
            display: block;
        } */

        .tab>label {
            display: block;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out;
            text-decoration: none;
            color: #0d6efd;
            border: 0;
            border-radius: 0.375rem;
            background: 0 0;
        }

        .tab>input[type="radio"]:checked+label {
            cursor: default;
            color: #fff;
            background-color: #0d6efd;
        }

        #saveQuestion {
            border: 1px solid black;
            padding: 30px;
            width: max-content;
            margin-left: auto;
            margin-right: auto;
            position: fixed;
            z-index: 9999;
            top: 50%;
            left: 50%;
            display: none;
        }
    </style>
</head>

<body>
    <!-- Необычные случаи 700 700 450 200; 400 400 140 120 -->
    <form id="canvasForm">
        <label for="canvasWidth">Ширина:</label>
        <input type="number" id="canvasWidth" value="600" required>
        <label for="canvasHeight">Высота:</label>
        <input type="number" id="canvasHeight" value="600" required>
        <label for="rectWidth">Ширина прямоугольника:</label>
        <input type="number" id="rectWidth" value="145" required>
        <label for="rectHeight">Высота прямоугольника:</label>
        <input type="number" id="rectHeight" value="30" required>
        <label for="inentM">Минимальный отступ:</label>
        <input type="number" id="inentM" value="10" required>
        <label for="minLayer">Количество слоев</label>
        <input type="number" id="minLayer" value="1" required>
        <button type="button" id='plus'>+</button>
        <!-- <button type="button" id='dob'>Добавить прямоугольник</button> -->
        <button type="submit">Apply</button>
    </form>

    <div class="tab">
    </div>

    <button type="button" id="save">Save</button>

    <canvas id="myCanvas" width="800" height="800"></canvas>
    <ul>
        <li><strike>Стрелки 2 слева не по центру</strike></li>
        <li><strike>Проверка на квадраты (менять стрелочки)</strike></li>
        <li><strike>Проверка на кладку диагональную (высота среди широты) (440 420 140 120 6)</strike></li>
        <li><strike>Менять местами при кладке при доп горизонт, допВерт</strike></li>
        <li><strike>Перенести все в центр</strike></li> +
        <li><strike>Добавить отступы</strike></li>
        <li><strike>Запрет выхода за пределы поля</strike></li> +
        <!-- <li></li> -->
        <li><strike>Исправить функции getRectangles и getRectNextLevel положить в отдельную функцию проверки и
                присвоение
                отступов</strike></li>
        <li><strike>Добавить просмотр слоев (через массив rectangles)</strike> </li>
        <li>Сохранять измененный слой руками и спрашивать при нажатии на дополнительный слой (либо на переход в другой
            слой без кнокпи сохранения) сделать ли все последующие такие (через 1) или нет</li> +-
        <li>Изменение масштаба либо окна (canvas) при изменении паллета</li>
        <li>Добавить в форму вопрос про кол-во мешков (Если нет параметра вычислять самостоятельно от массы + добавить в
            форму массу)</li>
        <li>Добавить возможность перемещения нескольких объектов (выделять их, разобрать код из test.html) (?)</li>
        <li>Приятный интерфейс</li>
    </ul>

    <div id="saveQuestion">
        <p>Сохранить изменения?</p>
        <button type="button" id="notSave">Нет</button>
        <!-- <button type="button" id="save">Да</button> -->
    </div>

    <script>
        "use strict";
        // Вероятне можно было сделать это с помощью div, (подумать об этом если это решение лучше, то переделать, если это не займет много времни. Пока оставляем все как есть)
        //Собирать все слои при нажатии на apply. При этом создавать вкладки со слоями (кнопки), где будут обтображаться все слои, их можно будет править и задавать эти исправления на другие слои например на чет или нечет. 1. Собрать все слои и отобразить их вместе. + 2. Сохронять все слои (под ними тоже, но в будущем сделать кнопку отключения всех предыдущих прямоугольников).+ 3. Добавить кнопку перемещения прямуокгоьников 

        const form = document.getElementById('canvasForm');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let selectedRectangle;

        let centerX, centerY, predelX, predelY;
        let rectWidth, rectHeight, rectCount;
        let rectangles = [];
        let inent;
        let level = 1;
        let layerNum = 0;
        let testArr = [];
        let arrText = ['↑', '→', '↓', '←'];
        let dragOffsetY, dragOffsetX;
        let rgbColor = ``;
        let dopCenterX = (parseInt(document.getElementById('myCanvas').width) - parseInt(document.getElementById('canvasWidth').value)) / 2;
        let dopCenterY = (parseInt(document.getElementById('myCanvas').height) - parseInt(document.getElementById('canvasHeight').value)) / 2;
        // let dopCenterX = 0;
        // let dopCenterY = 0;

        function float2int(value) {
            return value | 0; // Побитывая операция
        }

        function getInent(cPR) {
            let inentYArr = [];
            let inentXArr = [];
            let otherColumn = rectangles[cPR].column;
            let otherRow = -1;
            // console.log(rectangles.at(-1).row, rectangles.at(-1).column)
            for (let i = cPR; i < rectangles.length - 1; i++) {

                if (rectangles[i + 1].column != otherColumn) {
                    otherColumn = rectangles[i + 1].column;
                    inentYArr.push(float2int((canvasHeight.value / 2 - rectangles[i].y - inent - rectangles[i].height / 2 + dopCenterY) / (rectangles[i].row + 2)));
                    // console.log(rectangles[i].y, rectangles[i].column, rectangles[i].row, predelY,(predelY - rectangles[i].y) / (rectangles[i].row + 1))
                }
                if (otherRow != rectangles[i].row && rectangles[i].column == rectangles.at(-1).column) {

                    inentXArr.push(float2int((canvasWidth.value / 2 - rectangles[i].x - inent - rectangles[i].width / 2 + dopCenterX) / (rectangles[i].column + 2)));
                    // console.log(rectangles[i].x, rectangles[i].column, rectangles[i].row, canvasWidth.value / 2 - rectangles[i].x - rectangles[i].width / 2)
                }
            }
            inentYArr.push(float2int((canvasHeight.value / 2 - rectangles.at(-1).y - inent - rectangles.at(-1).height / 2 + dopCenterY) / (rectangles.at(-1).row + 2)));
            inentXArr.push(float2int((canvasWidth.value / 2 - rectangles.at(-1).x - inent - rectangles.at(-1).width / 2 + dopCenterX) / (rectangles.at(-1).column + 2)));

            // console.log(inentYArr)
            // console.log(inentXArr)
            for (let i = cPR; i < rectangles.length; i++) {
                rectangles[i].x += ((inentXArr[rectangles[i].row] < 0) ? 0 : inentXArr[rectangles[i].row] * (rectangles[i].column + 1));
                rectangles[i].y += ((inentYArr[rectangles[i].column] < 0) ? 0 : inentYArr[rectangles[i].column] * (rectangles[i].row + 1));
                rectangles[i].xAuto = rectangles[i].x;
                rectangles[i].yAuto = rectangles[i].y;
            }


        }

        function getCoord(arr) {
            let countPastRec = rectangles.length; // Исправить 
            let coordinateX = 0;
            let coordinateY = 0;
            let text = arrText[2];
            let arrLength = arr.length;
            arr = arr[0].map((_, colIndex) => arr.map(row => row[colIndex]));
            console.log(arr)

            for (let i = 0; i < arr.length; i++) {
                text = arrText[2];
                if (!rectangles?.at(-1)?.isLastlayer) {
                    rgbColor = `rgb(${getRandomInt(255)} ${getRandomInt(255)} ${getRandomInt(255)} / 30%)`;
                    // countPastRec = rectangles.length;
                }

                for (let j = 0; j < arr[i].length; j++) {
                    if (arr[i][j] == undefined) {
                        continue
                    }
                    if (arr[i][j] == 2) {
                        changeWidthHeight();
                        if (i == 0) {
                            text = arrText[1];
                        } else {
                            text = arrText[3]
                        }

                    } else {
                        if (j == 0) {
                            text = arrText[2];
                        } else {
                            text = arrText[0]
                        }
                    }
                    if (i != 0) {
                        // Проверки (когда не все фигуры в одном положении, то расставить так чтобы не было лишних отступов)
                        // console.log((i * arrLength) + (j + 1) - arrLength - 1 + countPastRec)
                        if (rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width > rectWidth) {
                            coordinateX = rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].x + rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width - Math.floor(rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width - rectWidth) / 2;
                        } else if (rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width < rectWidth) {
                            coordinateX = rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].x + rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width + Math.floor(rectWidth - rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width) / 2;
                        } else {
                            coordinateX = rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].x + rectangles[(i * arrLength) + (j + 1) - arrLength - 1 + countPastRec].width;

                        }


                    } else {
                        coordinateX = -(centerX - rectWidth / 2) + dopCenterX; // Базовый случай, когда все повернуты в 1 сторону
                    }

                    if (j == 0) {
                        coordinateY = -(centerY - rectHeight / 2) + dopCenterY;
                    } else {
                        if (rectangles.at(-1).height > rectHeight) {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height - Math.floor(rectangles.at(-1).height - rectHeight) / 2;
                        } else if (rectangles.at(-1).height < rectHeight) {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height + Math.floor(rectHeight - rectangles.at(-1).height) / 2;
                        } else {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height;  // Базовый случай, когда все повернуты в 1 сторону
                        }
                    }
                    
                    let a = { x: coordinateX + inent, y: coordinateY + inent, width: rectWidth, height: rectHeight, isDragging: false, isLastlayer: true, color: rgbColor, text: text, column: i, row: j, layer: level, xAuto: 0, yAuto: 0 };
                    rectangles.push(a);
                    

                    if (arr[i][j] == 2) {
                        changeWidthHeight();
                    }
                }

            }

            // getInent(countPastRec);
            console.log(rectangles.length, rectangles)

            // let dopArr =  rectangles.filter((r) => (Math.abs(r.x) + inent <= (centerX - r.width / 2 + dopCenterX) && Math.abs(r.y) + inent <= (centerY - r.height / 2 + dopCenterY)));
            // if (dopArr.length != rectangles.length){
            //     // console.log('jhkh')
                let dopArr1 = rectangles.filter((r) => (Math.abs(r.x) + inent > (centerX - r.width / 2 + dopCenterX) || Math.abs(r.y) + inent > (centerY - r.height / 2 + dopCenterY)));
            //     console.log(dopArr1)
            //     for(let i = 0; i < dopArr1.length; i++){
            //         console.log(dopArr1[i].row, dopArr1[i].column)
            //     }
            //     rectangles = dopArr
                
            // }
            // (countPastRec != 0) ? countPastRec -= dopArr1.length: 0;
            // console.log(countPastRec)
            // rectangles = rectangles.filter((r) => (Math.abs(r.x) + inent <= (centerX - r.width / 2 + dopCenterX) && Math.abs(r.y) + inent <= (centerY - r.height / 2 + dopCenterY)));
           
            // console.log(rectangles)
            //  ----------------------------------------------------------------------------------------------------------------------------------------------------------
            //Исправить ошибку (600 600 140 180 30 2) с отключенным getInput работает, но случай не стандартный, надо доделать, также исправить getInent чтобы работала и с этим случаем тоже. Потому что как-то неправильно передается массив с прямоугольнирками пишет нужное кол-во а внутри больше.
            // Испраивть 600 600 190 120 10 2
            // getInent(countPastRec);

            // console.log(rectangles)

        }


        function changeWidthHeight() {
            let dop = rectWidth;
            rectWidth = rectHeight;
            rectHeight = dop;
            predelX = centerX - rectWidth / 2;
            predelY = centerY - rectHeight / 2;
            // turn += 90;
        }

        let bullArr = [];

        function findNumberOfRectangles(canvasWidth, canvasHeight) {
            let plusHoriz = 0;
            let plusVert = 0;
            let max_horizontal = Math.floor((canvasWidth - inent) / (rectWidth + inent));
            let lengthRect = max_horizontal * (rectWidth + inent) + inent;
            let max_vertical = Math.floor((canvasHeight - inent) / (rectHeight + inent));
            let widthRect = max_vertical * (rectHeight + inent) + inent;


            if (lengthRect + rectHeight + inent <= canvasWidth) {
                plusHoriz++;
                while(lengthRect + (rectHeight + inent) * (plusHoriz + 1) <= canvasWidth){
                    plusHoriz++;
                    
                }
                // console.log(lengthRect + (rectHeight + inent) * (3), plusHoriz)
            }

            if (widthRect + rectWidth + inent <= canvasHeight) {

                plusVert = true;
            }
            bullArr.push([plusHoriz, plusVert])
           
            if (max_horizontal != 0 && max_vertical != 0) {
                testArr.push([max_horizontal, max_vertical]);
            } else {
                alert('Не подходящие параметры')
            }
            // console.log(testArr)
        }


        function evenLayer(canvasWidth, canvasHeight) {
            changeWidthHeight();
            findNumberOfRectangles(canvasWidth, canvasHeight);
            changeWidthHeight();
            let inentBetX, inentBetY;
            let matrixRectangles = [];
            for (let i = 0; i < testArr[1][1]; i++) {
                let dopArr = [];

                for (let j = 0; j < testArr[1][0]; j++) {
                    dopArr.push(2);
                }
                matrixRectangles.push(dopArr);
            }



            // if (bullArr[1][0]) {
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].splice(i, 0, 1);
            //     }
            // }

            // if (bullArr[1][1]) {
            //     let dopArr = [];
            //     while (dopArr.length != matrixRectangles[0].length) {
            //         dopArr.push(2);
            //     }
            //     matrixRectangles.push(dopArr);
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].pop();
            //         matrixRectangles[i].splice(i, 0, 1);
            //     }
            // }
           

            if (bullArr[1][0]) {
                for (let i = 0; i < matrixRectangles.length; i++) {
                    matrixRectangles[i].push(1);
                }
            }
            
            if (bullArr[1][1]){
                console.log(testArr)
                let dopArr =[]
                for (let i = 0; i < testArr[1][1]; i++) {
                    dopArr.push(1);
                }
                matrixRectangles.push(dopArr)
            }
            // console.log(matrixRectangles)
            getCoord(matrixRectangles);


        }

        //Проблема в том что у меня неверно выстраиваются матрицы, когда dopHoriz and dopVert

        function oddLayer(canvasWidth, canvasHeight) {
            let matrixRectangles = [];
            centerX = Math.floor(canvasWidth / 2);
            centerY = Math.floor(canvasHeight / 2);
            findNumberOfRectangles(canvasWidth, canvasHeight);
            for (let i = 0; i < testArr[0][1]; i++) {
                let dopArr = [];

                for (let j = 0; j < testArr[0][0]; j++) {
                    dopArr.push(1);
                }
                matrixRectangles.push(dopArr);
            }
            
            // if (bullArr[0][0]) {
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].splice(i, 0, 2);
            //     }
            // }

            // if (bullArr[0][1]) {
            //     let dopArr = [];
            //     while (dopArr.length != matrixRectangles[0].length) {
            //         dopArr.push(1);
            //     }
            //     matrixRectangles.push(dopArr);
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].pop();
            //         matrixRectangles[i].splice(i, 0, 2);
            //     }
            // }

            if (bullArr[0][0]) {
                console.log(bullArr[0][0])
                for (let i = 0; i < testArr[0][0]; i++) {
                   for(let j = 0; j < bullArr[0][0]; j++){
                    matrixRectangles[i].push(2);
                   }
                    
                }
            }
            
            if (bullArr[0][1]){
                let dopArr =[]
                for (let i = 0; i < testArr[0][1]; i++) {
                    dopArr.push(2);
                }
                matrixRectangles.push(dopArr)
            }
            // console.log(matrixRectangles)
           
            getCoord(matrixRectangles);

        }





        form.addEventListener('submit', function (event) {
            event.preventDefault();
            rectangles = [];
            bullArr = [];
            testArr = [];
            level = 1;

            let child = tab.lastElementChild;
            while (child) {
                tab.removeChild(child);
                child = tab.lastElementChild;
            }

            const canvasWidth = parseInt(document.getElementById('canvasWidth').value);
            const canvasHeight = parseInt(document.getElementById('canvasHeight').value);
            inent = Number(document.getElementById('inentM').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            rectHeight = parseInt(document.getElementById('rectHeight').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            let layer = parseInt(document.getElementById('minLayer').value);

            // Показ всех слоев одновременно
            for (let i = 0; i < layer; i++) {
                for (let i = 0; i < rectangles.length; i++) {
                    rectangles[i].isLastlayer = false;
                }

                // getRectangles(canvasWidth, canvasHeight);
                if (level % 2 == 0) {
                    evenLayer(canvasWidth, canvasHeight);
                    level += 1;
                } else {
                    oddLayer(canvasWidth, canvasHeight);
                    level += 1;
                }
            }

            createButton(layer);
            // console.log(rectangles)
            // oddLayer(canvasWidth, canvasHeight);
            layerNum = layer;
            drawLayer();
        });


        const tab = document.querySelector('.tab');
        function createButton(quantity) {

            for (let i = 1; i <= quantity; i++) {
                // <input checked id="tab-btn-1" name="tab-btn" type="radio" value="">
                // <label for="tab-btn-1">Вкладка 1</label>
                const button = document.createElement('input');
                button.setAttribute('type', 'radio');
                button.setAttribute("checked", "");
                button.name = "tab-bth";
                button.id = `tab-bth-${i}`;
                button.classList.add('btn');
                button.addEventListener('click', () => {
                    for (let i = 0; i < rectangles.length; i++) {
                        rectangles[i].x = rectangles[i].xAuto;

                        rectangles[i].y = rectangles[i].yAuto;
                    }
                    layerNum = i;
                    // confirm('Save iz')
                    drawLayer();
                })
                tab.appendChild(button);
                const label = document.createElement('label');
                label.setAttribute("for", `tab-bth-${i}`);
                label.innerHTML = `Слой ${i}`
                tab.appendChild(label);
            }

        }

        function drawLayer() {
            let startLayer = -1;
            let endLayer = -1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < rectangles.length; i++) {
                rectangles[i].isLastlayer = false;
                // console.log(layerNum);
                if (rectangles[i].layer == layerNum && startLayer == -1) {
                    startLayer = i;
                }
                if (rectangles[i].layer == layerNum + 1 && endLayer == -1) {
                    endLayer = i;
                }
            }

            for (let i = startLayer; i < ((endLayer == -1) ? rectangles.length : endLayer); i++) {
                // if (!rectangles[i].isLastlayer)
                rectangles[i].isLastlayer = true;
            }
            // console.log(startLayer, endLayer, rectangles.length)
            rectangles.slice(0, ((endLayer == -1) ? rectangles.length : endLayer)).forEach(drawRectangle);
        }


        function drawPallet() {
            const canvasWidth = parseInt(document.getElementById('canvasWidth').value);
            const canvasHeight = parseInt(document.getElementById('canvasHeight').value);
            // ctx.strokeRect( 0, 0, canvasWidth, canvasHeight);
            ctx.strokeRect(dopCenterX, dopCenterY, canvasWidth, canvasHeight);
            //  ctx.translate(canvas.width / 2, canvas.height / 2);
        }

        save.addEventListener('click', () => {
            for (let i = 0; i < rectangles.length; i++) {
                rectangles[i].xAuto = rectangles[i].x;
                rectangles[i].yAuto = rectangles[i].y;
            }
        });


        // const element = document.querySelector('button')

        // element.addEventListener('click', function (event) {

        //     const canvasWidth = parseInt(document.getElementById('canvasWidth').value);
        //     const canvasHeight = parseInt(document.getElementById('canvasHeight').value);
        //     level += 1;
        //     for (let i = 0; i < rectangles.length; i++) {
        //         rectangles[i].isLastlayer = false;
        //     }

        //     // getRectangles(canvasWidth, canvasHeight);
        //     if (level % 2 == 0) {
        //         evenLayer(canvasWidth, canvasHeight);
        //     } else {
        //         oddLayer(canvasWidth, canvasHeight);
        //     }
        //     // getRectNextLevel();

        //     drawRectangles();
        // });




        function drawRectangle(rect) {
            ctx.beginPath();
            drawPallet();
            drawNumbers(rect);
            drawArrow(rect);

            // if (rect.xDragging != -100000 || rect.yDragging != -100000) {
            //     ctx.rect(centerX + rect.xDragging - rect.width / 2, centerY + rect.yDragging - rect.height / 2, rect.width, rect.height);
            //     rect.xDragging = -100000;
            //     rect.yDragging = -100000
            // } else {
            // rect.x += dopCenterX;
            ctx.rect(centerX + rect.x - rect.width / 2, centerY + rect.y - rect.height / 2, rect.width, rect.height);
            // }

            ctx.fillStyle = rect.color;
            ctx.fill();
            if (!rect.isLastlayer) {
                ctx.strokeStyle = rect.color;
            } else {
                ctx.strokeStyle = 'black'
            }

            ctx.stroke();
        }

        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }


        function drawNumbers(rect) {
            ctx.font = "15px arial";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }

            let text = (rect.x).toString() + ', ' + (-rect.y).toString();
            ctx.fillText(text, centerX + rect.x, centerY + rect.y);
        }

        function drawArrow(rect) {
            ctx.font = "24px arial";
            ctx.textBaseline = "middle";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }
            if (rect.text == '↑') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
            } else if (rect.text == '→') {
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else if (rect.text == '←') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            }

        }

        // function drawRectangles() {
        //     ctx.clearRect(0, 0, canvas.width, canvas.height);
        //     rectangles.forEach(drawRectangle);
        // }



        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isInsideRect(mousePos, rect) {
            return mousePos.x > centerX + rect.x - rect.width / 2 &&
                mousePos.x < centerX + rect.x + rect.width / 2 &&
                mousePos.y > centerY + rect.y - rect.height / 2 &&
                mousePos.y < centerY + rect.y + rect.height / 2;
        }



        canvas.addEventListener('mousedown', function (evt) {

            const mousePos = getMousePos(canvas, evt);
            rectangles.forEach(rect => {
                if (isInsideRect(mousePos, rect) && rect.isLastlayer) {
                    selectedRectangle = rect;
                    dragOffsetX = mousePos.x - (centerX + rect.x);
                    dragOffsetY = mousePos.y - (centerY + rect.y);
                    rect.isDragging = true;
                }
            });
            if (evt.button === 1) {
                evt.preventDefault();
                let dop = selectedRectangle.height;
                selectedRectangle.height = selectedRectangle.width;
                selectedRectangle.width = dop;
                selectedRectangle.isDragging = false;
                if (arrText.indexOf(selectedRectangle.text) + 1 < arrText.length) {
                    selectedRectangle.text = arrText[arrText.indexOf(selectedRectangle.text) + 1];
                } else {
                    selectedRectangle.text = arrText[0];
                }

                drawLayer();

            }
        });

        canvas.addEventListener('mousemove', function (evt) {
            if (selectedRectangle && selectedRectangle.isDragging) {
                const mousePos = getMousePos(canvas, evt);
                if ((mousePos.x - centerX - dragOffsetX) > 0) {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) > (centerX - selectedRectangle.width / 2 + dopCenterX)) ? (centerX - selectedRectangle.width / 2 + dopCenterX) : mousePos.x - centerX - dragOffsetX;
                } else {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) < -(centerX - selectedRectangle.width / 2 - dopCenterX)) ? -(centerX - selectedRectangle.width / 2 - dopCenterX) : mousePos.x - centerX - dragOffsetX;
                }

                if ((mousePos.y - centerY - dragOffsetY) > 0) {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) > (centerY - selectedRectangle.height / 2 + dopCenterY)) ? (centerY - selectedRectangle.height / 2 + dopCenterY) : mousePos.y - centerY - dragOffsetY;
                } else {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) < -(centerY - selectedRectangle.height / 2 - dopCenterY)) ? -(centerY - selectedRectangle.height / 2 - dopCenterY) : mousePos.y - centerY - dragOffsetY;
                }

                // selectedRectangle.y = mousePos.y - centerY - dragOffsetY;
                drawLayer();
            }
        });

        canvas.addEventListener('mouseup', function () {
            if (selectedRectangle) {
                selectedRectangle.isDragging = false;
                selectedRectangle = null;
            }
        });

        // Инициализация при загрузке
        form.dispatchEvent(new Event('submit'));
    </script>
</body>

</html>