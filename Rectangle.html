<!DOCTYPE html>
<html>

<head>
    <title>Draggable Rectangles</title>
    <style>
        body {
            -ms-user-select: none;
            -moz-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            border: 1px solid black;
            display: block;
            margin-top: 20px;
            margin-left: 20px;
        }

        form {
            display: flex;
            flex-direction: column;
            width: 200px;
            margin-bottom: 20px;
        }

        .tab {
            display: flex;
            flex-wrap: wrap;
        }

        .tab>input[type="radio"] {
            display: none;
        }

        .tab-content {
            display: none;
            width: 100%;
            margin-top: 1rem;
        }

        .tab>label {
            display: block;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out;
            text-decoration: none;
            color: #0d6efd;
            border: 0;
            border-radius: 0.375rem;
            background: 0 0;
        }

        .tab>input[type="radio"]:checked+label {
            cursor: default;
            color: #fff;
            background-color: #0d6efd;
        }

        #saveQuestion {
            border: 1px solid black;
            padding: 30px;
            width: max-content;
            margin-left: auto;
            margin-right: auto;
            position: fixed;
            z-index: 9999;
            top: 50%;
            left: 50%;
            display: none;
        }
    </style>
</head>

<body>
    <!-- Необычные случаи 700 700 450 200; 400 400 140 120 -->
    <form id="canvasForm">
        <label for="canvasWidth">Ширина:</label>
        <input type="number" id="canvasWidth" value="600" required>
        <label for="canvasHeight">Высота:</label>
        <input type="number" id="canvasHeight" value="600" required>
        <label for="rectWidth">Ширина прямоугольника:</label>
        <input type="number" id="rectWidth" value="145" required>
        <label for="rectHeight">Высота прямоугольника:</label>
        <input type="number" id="rectHeight" value="30" required>
        <label for="inentM">Минимальный отступ:</label>
        <input type="number" id="inentM" value="10" required>
        <label for="minLayer">Количество слоев</label>
        <input type="number" id="minLayer" value="1" required>
        <button type="button" id='plus'>+</button>
        <!-- <button type="button" id='dob'>Добавить прямоугольник</button> -->
        <button type="submit">Apply</button>
    </form>

    <div class="tab">
    </div>

    <button type="button" id="save">Save</button>

    <canvas id="myCanvas" width="800" height="800"></canvas>
    <ul>
        
        
        <li><strike>Проверка на кладку диагональную (высота среди широты) (440 420 140 120 6)</strike></li>
        <li><strike>Менять местами при кладке при доп горизонт, допВерт</strike></li>
        <li>Сохранять измененный слой руками и спрашивать при нажатии на дополнительный слой (либо на переход в другой
            слой без кнокпи сохранения) сделать ли все последующие такие (через 1) или нет</li> +-
        <li>Изменение масштаба либо окна (canvas) при изменении паллета</li>
        <li>Добавить в форму вопрос про кол-во мешков (Если нет параметра вычислять самостоятельно от массы + добавить в
            форму массу)</li>
        <li>Добавить возможность перемещения нескольких объектов (выделять их, разобрать код из test.html) (?)</li>
        <li>Приятный интерфейс</li>
    </ul>

    <div id="saveQuestion">
        <p>Сохранить изменения?</p>
        <button type="button" id="notSave">Нет</button>
        <!-- <button type="button" id="save">Да</button> -->
    </div>

    <script>
        "use strict";
     

        const form = document.getElementById('canvasForm');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let selectedRectangle;

        let centerX, centerY, predelX, predelY;
        let rectWidth, rectHeight, rectCount;
        let rectangles = [];
        let inent;
        let level = 1;
        let layerNum = 0;
        let arrText = ['↑', '→', '↓', '←'];
        let dragOffsetY, dragOffsetX;
        let rgbColor = ``;
        let dopCenterX = (parseInt(document.getElementById('myCanvas').width) - parseInt(document.getElementById('canvasWidth').value)) / 2;
        let dopCenterY = (parseInt(document.getElementById('myCanvas').height) - parseInt(document.getElementById('canvasHeight').value)) / 2;
        // let dopCenterX = 0;
        // let dopCenterY = 0;

        function float2int(value) {
            return value | 0; // Побитывая операция
        }

        function getInent(cPR) {
            let inentYArr = [];
            let inentXArr = [];
            let otherColumn = rectangles[cPR].column;
            let otherRow = -1;
            // console.log(rectangles.at(-1).row, rectangles.at(-1).column)
            for (let i = cPR; i < rectangles.length - 1; i++) {

                if (rectangles[i + 1].column != otherColumn) {
                    otherColumn = rectangles[i + 1].column;
                    inentYArr.push(float2int((canvasHeight.value / 2 - rectangles[i].y - inent - rectangles[i].height / 2 + dopCenterY) / (rectangles[i].row + 2)));
                    // console.log(rectangles[i].y, rectangles[i].column, rectangles[i].row, predelY,(predelY - rectangles[i].y) / (rectangles[i].row + 1))
                }
                if (otherRow != rectangles[i].row && rectangles[i].column == rectangles.at(-1).column) {

                    inentXArr.push(float2int((canvasWidth.value / 2 - rectangles[i].x - inent - rectangles[i].width / 2 + dopCenterX) / (rectangles[i].column + 2)));
                    // console.log(rectangles[i].x, rectangles[i].column, rectangles[i].row, canvasWidth.value / 2 - rectangles[i].x - rectangles[i].width / 2)
                }
            }
            inentYArr.push(float2int((canvasHeight.value / 2 - rectangles.at(-1).y - inent - rectangles.at(-1).height / 2 + dopCenterY) / (rectangles.at(-1).row + 2)));
            inentXArr.push(float2int((canvasWidth.value / 2 - rectangles.at(-1).x - inent - rectangles.at(-1).width / 2 + dopCenterX) / (rectangles.at(-1).column + 2)));

            // console.log(inentYArr)
            // console.log(inentXArr)
            for (let i = cPR; i < rectangles.length; i++) {
                rectangles[i].x += ((inentXArr[rectangles[i].row] < 0) ? 0 : inentXArr[rectangles[i].row] * (rectangles[i].column + 1));
                rectangles[i].y += ((inentYArr[rectangles[i].column] < 0) ? 0 : inentYArr[rectangles[i].column] * (rectangles[i].row + 1));
                rectangles[i].xAuto = rectangles[i].x;
                rectangles[i].yAuto = rectangles[i].y;
            }


        }

        function getCoord(arr) {
            let countPastRec = rectangles.length; // Исправить 
            let coordinateX = 0;
            let coordinateY = 0;
            let text = arrText[2];
            let arrLength = arr.length;
            // arr = arr[0].map((_, colIndex) => arr.map(row => row[colIndex]));
            // console.log(arr)

            for (let i = 0; i < arr.length; i++) {
                text = arrText[2];
                if (!rectangles?.at(-1)?.isLastlayer) {
                    rgbColor = `rgb(${getRandomInt(255)} ${getRandomInt(255)} ${getRandomInt(255)} / 30%)`;
                    // countPastRec = rectangles.length;
                }

                for (let j = 0; j < arr[i].length; j++) {
                    // if (arr[i][j] == undefined) {
                    //     continue
                    // }
                    if (arr[i][j] == 2) {
                        changeWidthHeight();
                        if (i == 0) {
                            text = arrText[1];
                        } else {
                            text = arrText[3]
                        }

                    } else {
                        if (j == 0) {
                            text = arrText[2];
                        } else {
                            text = arrText[0]
                        }
                    }
                    if (i != 0) {
                        // Проверки (когда не все фигуры в одном положении, то расставить так чтобы не было лишних отступов)
                        let rightIndex = (arr[i].length * (i - 1)) + j + countPastRec
                        // console.log(rightIndex)
                        if (rectangles[rightIndex].width > rectWidth) {
                            coordinateX = rectangles[rightIndex].x + rectangles[rightIndex].width - Math.floor(rectangles[rightIndex].width - rectWidth) / 2;
                        } else if (rectangles[rightIndex].width < rectWidth) {
                            coordinateX = rectangles[rightIndex].x + rectangles[rightIndex].width + Math.floor(rectWidth - rectangles[rightIndex].width) / 2;
                        } else {
                            coordinateX = rectangles[rightIndex].x + rectangles[rightIndex].width;
                            // console.log((i * arrLength))
                        }


                    } else {
                        coordinateX = float2int(-(centerX - rectWidth / 2) + dopCenterX);
                    }

                    if (j == 0) {
                        coordinateY = float2int(-(centerY - rectHeight / 2) + dopCenterY);
                    } else {
                        if (rectangles.at(-1).height > rectHeight) {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height - Math.floor(rectangles.at(-1).height - rectHeight) / 2;
                        } else if (rectangles.at(-1).height < rectHeight) {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height + Math.floor(rectHeight - rectangles.at(-1).height) / 2;
                        } else {
                            coordinateY = rectangles.at(-1).y + rectangles.at(-1).height;
                        }
                    }

                    let a = { x: coordinateX + inent, y: coordinateY + inent, width: rectWidth, height: rectHeight, isDragging: false, isLastlayer: true, color: rgbColor, text: text, column: i, row: j, layer: level, xAuto: 0, yAuto: 0 };
                    rectangles.push(a);


                    if (arr[i][j] == 2) {
                        changeWidthHeight();
                    }
                }

            }

            // getInent(countPastRec);

            // rectangles = rectangles.filter((r) => (Math.abs(r.x) + inent <= (centerX - r.width / 2 + dopCenterX) && Math.abs(r.y) + inent <= (centerY - r.height / 2 + dopCenterY)));
            console.log(rectangles)

        }


        function changeWidthHeight() {
            let dop = rectWidth;
            rectWidth = rectHeight;
            rectHeight = dop;
            predelX = centerX - rectWidth / 2;
            predelY = centerY - rectHeight / 2;
            // turn += 90;
        }

        function findDopRectangles(canvasWidth, canvasHeight, lengthRect, widthRect) {
            let dopHoriz = 0;
            let dopVert = 0;
            if (lengthRect + rectHeight + inent <= canvasWidth) {
                dopHoriz++;
                while (lengthRect + (rectHeight + inent) * (dopHoriz + 1) <= canvasWidth) {
                    dopHoriz++;
                }
                if (rectWidth + inent + inent <= canvasHeight) {
                    dopVert++;
                    while ((rectWidth + inent) * (dopVert + 1) + inent <= canvasHeight) {
                        dopVert++;
                    }
                } else {
                    dopHoriz = 0;
                }
            } else if (widthRect + rectWidth + inent <= canvasHeight) {
                dopVert++;
                while (widthRect + (rectWidth + inent) * (dopVert + 1) <= canvasHeight) {
                    dopVert++;
                }
                if (rectHeight + inent + inent <= canvasWidth) {
                    dopHoriz++;
                    while ((rectHeight + inent) * (dopHoriz + 1) + inent <= canvasWidth) {
                        dopHoriz++;
                    }
                } else {
                    dopVert = 0;
                }
            }
            return [dopVert, dopHoriz];
        }

        function findNumberOfRectangles(canvasWidth, canvasHeight) {
            // let dopRectangles = {};
            let numRectangles = {};

            let numHorizontal = Math.floor((canvasWidth - inent) / (rectWidth + inent));
            let lengthRect = numHorizontal * (rectWidth + inent) + inent;
            let numVertical = Math.floor((canvasHeight - inent) / (rectHeight + inent));
            let widthRect = numVertical * (rectHeight + inent) + inent;

            let [dopHoriz, dopVert] = findDopRectangles(canvasWidth, canvasHeight, lengthRect, widthRect)

            if (numHorizontal != 0 && numVertical != 0) {
                numRectangles = { horizontal: numHorizontal, vertical: numVertical, dopHoriz: dopHoriz, dopVert: dopVert };
            } else {
                alert('Не подходящие параметры')
            }

            return numRectangles;

        }


        function evenLayer(canvasWidth, canvasHeight) {
            // changeWidthHeight();

            let [testArr, dopRectangles] = findNumberOfRectangles(canvasWidth, canvasHeight);
            // changeWidthHeight();

            let matrixRectangles = [];
            for (let i = 0; i < testArr[1][1]; i++) {
                let dopArr = [];

                for (let j = 0; j < testArr[1][0]; j++) {
                    dopArr.push(2);
                }
                matrixRectangles.push(dopArr);
            }



            // if (dopRectangles[1][0]) {
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].splice(i, 0, 1);
            //     }
            // }

            // if (dopRectangles[1][1]) {
            //     let dopArr = [];
            //     while (dopArr.length != matrixRectangles[0].length) {
            //         dopArr.push(2);
            //     }
            //     matrixRectangles.push(dopArr);
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].pop();
            //         matrixRectangles[i].splice(i, 0, 1);
            //     }
            // }


            if (dopRectangles[1][0]) {
                for (let i = 0; i < matrixRectangles.length; i++) {
                    matrixRectangles[i].push(1);
                }
            }

            if (dopRectangles[1][1]) {
                console.log(testArr)
                let dopArr = []
                for (let i = 0; i < testArr[1][1]; i++) {
                    dopArr.push(1);
                }
                matrixRectangles.push(dopArr)
            }
            // console.log(matrixRectangles)
            getCoord(matrixRectangles);


        }

        //Проблема в том что у меня неверно выстраиваются матрицы, когда dopHoriz and dopVert
        function oddLayer(canvasWidth, canvasHeight) {
            let matrixRectangles = [];
            centerX = Math.floor(canvasWidth / 2) + dopCenterX;
            centerY = Math.floor(canvasHeight / 2) + dopCenterY;
            let numRectangles = findNumberOfRectangles(canvasWidth, canvasHeight);

            let differenceValues = float2int(Math.max(rectHeight, rectWidth) / Math.min(rectHeight, rectWidth));

            for (let i = 0; i < numRectangles.horizontal; i++) {

                matrixRectangles.push(Array(numRectangles.vertical).fill(1));
            }
            // if (numRectangles.dopHoriz) {
            //     for (let i = 0; i < matrixRectangles.length; i++) {
            //         matrixRectangles[i].splice(i * numRectangles.dopVert, numRectangles.dopVert, ...Array(numRectangles.dopVert).fill(2));
            //     }

            //     console.log(matrixRectangles)

            // }
            console.log(matrixRectangles)
            getCoord(matrixRectangles);

        }





        form.addEventListener('submit', function (event) {
            event.preventDefault();
            rectangles = [];
            // dopRectangles = [];
            // testArr = [];
            dopCenterX = float2int((parseInt(document.getElementById('myCanvas').width) - parseInt(document.getElementById('canvasWidth').value)) / 2);
            dopCenterY = float2int((parseInt(document.getElementById('myCanvas').height) - parseInt(document.getElementById('canvasHeight').value)) / 2);
            level = 1;

            let child = tab.lastElementChild;
            while (child) {
                tab.removeChild(child);
                child = tab.lastElementChild;
            }

            const canvasWidth = parseInt(document.getElementById('canvasWidth').value);
            const canvasHeight = parseInt(document.getElementById('canvasHeight').value);
            inent = Number(document.getElementById('inentM').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            rectHeight = parseInt(document.getElementById('rectHeight').value);
            rectWidth = parseInt(document.getElementById('rectWidth').value);
            let layer = parseInt(document.getElementById('minLayer').value);

            // Показ всех слоев одновременно
            for (let i = 0; i < layer; i++) {
                for (let i = 0; i < rectangles.length; i++) {
                    rectangles[i].isLastlayer = false;
                }

                // getRectangles(canvasWidth, canvasHeight);
                if (level % 2 == 0) {
                    evenLayer(canvasWidth, canvasHeight);
                    level += 1;
                } else {
                    oddLayer(canvasWidth, canvasHeight);
                    level += 1;
                }
            }

            createButton(layer);
            // console.log(rectangles)
            // oddLayer(canvasWidth, canvasHeight);
            layerNum = layer;
            drawLayer();
        });


        const tab = document.querySelector('.tab');
        function createButton(quantity) {

            for (let i = 1; i <= quantity; i++) {
                // <input checked id="tab-btn-1" name="tab-btn" type="radio" value="">
                // <label for="tab-btn-1">Вкладка 1</label>
                const button = document.createElement('input');
                button.setAttribute('type', 'radio');
                button.setAttribute("checked", "");
                button.name = "tab-bth";
                button.id = `tab-bth-${i}`;
                button.classList.add('btn');
                button.addEventListener('click', () => {
                    for (let i = 0; i < rectangles.length; i++) {
                        rectangles[i].x = rectangles[i].xAuto;

                        rectangles[i].y = rectangles[i].yAuto;
                    }
                    layerNum = i;
                    // confirm('Save iz')
                    drawLayer();
                })
                tab.appendChild(button);
                const label = document.createElement('label');
                label.setAttribute("for", `tab-bth-${i}`);
                label.innerHTML = `Слой ${i}`
                tab.appendChild(label);
            }

        }

        function drawLayer() {
            let startLayer = -1;
            let endLayer = -1;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < rectangles.length; i++) {
                rectangles[i].isLastlayer = false;
                // console.log(layerNum);
                if (rectangles[i].layer == layerNum && startLayer == -1) {
                    startLayer = i;
                }
                if (rectangles[i].layer == layerNum + 1 && endLayer == -1) {
                    endLayer = i;
                }
            }

            for (let i = startLayer; i < ((endLayer == -1) ? rectangles.length : endLayer); i++) {
                // if (!rectangles[i].isLastlayer)
                rectangles[i].isLastlayer = true;
            }
            // console.log(startLayer, endLayer, rectangles.length)
            rectangles.slice(0, ((endLayer == -1) ? rectangles.length : endLayer)).forEach(drawRectangle);
        }


        function drawPallet() {
            const canvasWidth = parseInt(document.getElementById('canvasWidth').value);
            const canvasHeight = parseInt(document.getElementById('canvasHeight').value);
            // ctx.strokeRect( 0, 0, canvasWidth, canvasHeight);
            ctx.strokeRect(dopCenterX, dopCenterY, canvasWidth, canvasHeight);
            //  ctx.translate(canvas.width / 2, canvas.height / 2);
        }

        save.addEventListener('click', () => {
            for (let i = 0; i < rectangles.length; i++) {
                rectangles[i].xAuto = rectangles[i].x;
                rectangles[i].yAuto = rectangles[i].y;
            }
        });


        function drawRectangle(rect) {
            ctx.beginPath();
            drawPallet();
            drawNumbers(rect);
            drawArrow(rect);

            ctx.rect(centerX + rect.x - float2int(rect.width / 2), centerY + rect.y - float2int(rect.height / 2), rect.width, rect.height);

            ctx.fillStyle = rect.color;
            ctx.fill();
            if (!rect.isLastlayer) {
                ctx.strokeStyle = rect.color;
            } else {
                ctx.strokeStyle = 'black'
            }

            ctx.stroke();
        }

        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }


        function drawNumbers(rect) {
            ctx.font = "15px arial";
            ctx.textBaseline = "middle";
            ctx.textAlign = "center";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }

            let text = (rect.x).toString() + ', ' + (-rect.y).toString();
            ctx.fillText(text, centerX + rect.x, centerY + rect.y);
        }

        function drawArrow(rect) {
            ctx.font = "24px arial";
            ctx.textBaseline = "middle";
            if (!rect.isLastlayer) {
                ctx.fillStyle = rect.color;
            } else {
                ctx.fillStyle = 'black'
            }
            if (rect.text == '↑') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
            } else if (rect.text == '→') {
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else if (rect.text == '←') {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY - Math.floor(rect.height / 2) + 15);
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            } else {
                ctx.fillText(rect.text, centerX + rect.x - Math.floor(rect.width / 2) + 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);
                ctx.fillText(rect.text, centerX + rect.x + Math.floor(rect.width / 2) - 15, rect.y + centerY + Math.floor(rect.height / 2) - 15);

            }

        }


        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function isInsideRect(mousePos, rect) {
            return mousePos.x > centerX + rect.x - float2int(rect.width / 2) &&
                mousePos.x < centerX + rect.x + float2int(rect.width / 2) &&
                mousePos.y > centerY + rect.y - float2int(rect.height / 2) &&
                mousePos.y < centerY + rect.y + float2int(rect.height / 2);
        }



        canvas.addEventListener('mousedown', function (evt) {

            const mousePos = getMousePos(canvas, evt);
            rectangles.forEach(rect => {
                if (isInsideRect(mousePos, rect) && rect.isLastlayer) {
                    selectedRectangle = rect;
                    dragOffsetX = mousePos.x - (centerX + rect.x);
                    dragOffsetY = mousePos.y - (centerY + rect.y);
                    rect.isDragging = true;
                }
            });
            if (evt.button === 1) {
                evt.preventDefault();
                let dop = selectedRectangle.height;
                selectedRectangle.height = selectedRectangle.width;
                selectedRectangle.width = dop;
                selectedRectangle.isDragging = false;
                if (arrText.indexOf(selectedRectangle.text) + 1 < arrText.length) {
                    selectedRectangle.text = arrText[arrText.indexOf(selectedRectangle.text) + 1];
                } else {
                    selectedRectangle.text = arrText[0];
                }

                drawLayer();

            }
        });

        canvas.addEventListener('mousemove', function (evt) {
            if (selectedRectangle && selectedRectangle.isDragging) {
                const mousePos = getMousePos(canvas, evt);
                if ((mousePos.x - centerX - dragOffsetX) > 0) {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) > (centerX - float2int(selectedRectangle.width / 2) - dopCenterX)) ? (centerX - float2int(selectedRectangle.width / 2) - dopCenterX) : mousePos.x - centerX - dragOffsetX;
                } else {
                    selectedRectangle.x = ((mousePos.x - centerX - dragOffsetX) < -(centerX - float2int(selectedRectangle.width / 2) - dopCenterX)) ? -(centerX - float2int(selectedRectangle.width / 2) - dopCenterX) : mousePos.x - centerX - dragOffsetX;
                }

                if ((mousePos.y - centerY - dragOffsetY) > 0) {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) > (centerY - float2int(selectedRectangle.height / 2) - dopCenterY)) ? (centerY - float2int(selectedRectangle.height / 2) - dopCenterY) : mousePos.y - centerY - dragOffsetY;
                } else {
                    selectedRectangle.y = ((mousePos.y - centerY - dragOffsetY) < -(centerY - float2int(selectedRectangle.height / 2) - dopCenterY)) ? -(centerY - float2int(selectedRectangle.height / 2) - dopCenterY) : mousePos.y - centerY - dragOffsetY;
                }

                // selectedRectangle.y = mousePos.y - centerY - dragOffsetY;
                drawLayer();
            }
        });

        canvas.addEventListener('mouseup', function () {
            if (selectedRectangle) {
                selectedRectangle.isDragging = false;
                selectedRectangle = null;
            }
        });

        // Инициализация при загрузке
        form.dispatchEvent(new Event('submit'));
    </script>
</body>

</html>